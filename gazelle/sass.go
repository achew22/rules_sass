/* Copyright 2018 The Bazel Authors. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// gazelle provides a minimal implementation of language.Language for
// rules_sass.
package gazelle

import (
	"fmt"
	"io/ioutil"
	"path/filepath"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/bazelbuild/bazel-gazelle/rule"
)

var _ = fmt.Printf

type sasslang struct{}

// NewLanguage returns an instace of the Gazelle plugin for rules_sass.
func NewLanguage() language.Language {
	return &sasslang{}
}

// Kinds returns a map of maps rule names (kinds) and information on how to
// match and merge attributes that may be found in rules of those kinds. All
// kinds of rules generated for this language may be found here.
func (s *sasslang) Kinds() map[string]rule.KindInfo {
	return map[string]rule.KindInfo{
		"sass_library": {
			MatchAny: true,
			NonEmptyAttrs: map[string]bool{
				"srcs": true,
			},
			MergeableAttrs: map[string]bool{
				"srcs": true,
			},
			ResolveAttrs: map[string]bool{"deps": true},
		},
		"sass_binary": {
			MatchAny: true,
			NonEmptyAttrs: map[string]bool{
				"deps": true,
				"srcs": true,
			},
			MergeableAttrs: map[string]bool{
				"srcs": true,
				"src":  true,
			},
			ResolveAttrs: map[string]bool{"deps": true},
		},
	}
}

// Loads returns .bzl files and symbols they define. Every rule generated by
// GenerateRules, now or in the past, should be loadable from one of these
// files.
func (s *sasslang) Loads() []rule.LoadInfo {
	return []rule.LoadInfo{
		{
			Name:    "@io_bazel_rules_sass//:defs.bzl",
			Symbols: []string{"sass_binary", "sass_library"},
		},
	}
}

// GenerateRules extracts build metadata from source files in a directory.
// GenerateRules is called in each directory where an update is requested
// in depth-first post-order.
//
// args contains the arguments for GenerateRules. This is passed as a
// struct to avoid breaking implementations in the future when new
// fields are added.
//
// empty is a list of empty rules that may be deleted after merge.
//
// gen is a list of generated rules that may be updated or added.
//
// Any non-fatal errors this function encounters should be logged using
// log.Print.
func (s *sasslang) GenerateRules(args language.GenerateArgs) (empty, gen []*rule.Rule) {
	files, err := ioutil.ReadDir(args.Dir)
	if err != nil {
		panic(err)
	}

	// base is the last part of the path for this element. For example:
	// "hello_world" => "hello_world"
	// "foo/bar" => "bar"
	base := filepath.Base(args.Rel)

	rules := []*rule.Rule{}

	var normalFiles []string
	for _, file := range files {
		f := file.Name()

		// Only generate SASS entries for sass files (.scss/.sass)
		if !strings.HasSuffix(f, ".sass") && !strings.HasSuffix(f, ".scss") {
			continue
		}

		fileInfo := sassFileInfo(args.Dir, f)

		// The primary entrypoint on SASS is a main.scss file.
		if f == "main.scss" {
			rule := rule.NewRule("sass_binary", base)

			rule.SetAttr("src", "main.scss")
			rule.SetPrivateAttr(config.GazelleImportsKey, fileInfo.Imports)

			rules = append(rules, rule)
		} else if strings.HasPrefix(filepath.Base(f), "_") {
			// Libraries in SASS have filenames that start with _.
			base = filepath.Base(f)

			rule := rule.NewRule("sass_library", base[1:len(base)-5])

			rule.SetAttr("srcs", []string{base})
			rule.SetPrivateAttr(config.GazelleImportsKey, fileInfo.Imports)

			// These rules should always be public
			rule.SetAttr("visibility", []string{"//visibility:public"})

			rules = append(rules, rule)
		} else {
			normalFiles = append(normalFiles, f)
		}
	}

	if len(normalFiles) > 0 {
		rule := rule.NewRule("sass_library", base)

		rule.SetAttr("srcs", normalFiles)

		rules = append(rules, rule)
	}

	// For each file in the dir with a leading "_" create a new sass_library
	return nil, rules
}

// Fix repairs deprecated usage of language-specific rules in f. This is
// called before the file is indexed. Unless c.ShouldFix is true, fixes
// that delete or rename rules should not be performed.
func (s *sasslang) Fix(c *config.Config, f *rule.File) {
}
